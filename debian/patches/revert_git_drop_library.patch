Index: gnome-control-center-3.3.90/configure.ac
===================================================================
--- gnome-control-center-3.3.90.orig/configure.ac	2012-02-21 13:34:43.575097692 +0100
+++ gnome-control-center-3.3.90/configure.ac	2012-02-21 13:34:47.543097844 +0100
@@ -19,6 +19,14 @@
 LT_PREREQ([2.2])
 LT_INIT
 
+# .so version for libgnome-control-center
+LIBGNOMECONTROLCENTER_CURRENT=1
+LIBGNOMECONTROLCENTER_REVISION=0
+LIBGNOMECONTROLCENTER_AGE=0
+AC_SUBST(LIBGNOMECONTROLCENTER_CURRENT)
+AC_SUBST(LIBGNOMECONTROLCENTER_REVISION)
+AC_SUBST(LIBGNOMECONTROLCENTER_AGE)
+
 # Use the GNOME documentation framework
 GNOME_DOC_INIT
 
@@ -232,7 +240,7 @@
 PANEL_CFLAGS="-I\$(top_srcdir)/ -DG_LOG_DOMAIN=\"\\\"\$(cappletname)-cc-panel\\\"\""
 AC_SUBST(PANEL_CFLAGS)
 
-PANEL_LIBS=""
+PANEL_LIBS="\$(top_builddir)/libgnome-control-center/libgnome-control-center.la"
 AC_SUBST(PANEL_LIBS)
 
 PANEL_LDFLAGS="-export_dynamic -avoid-version -module -no-undefined -export-symbols-regex '^g_io_module_(load|unload)'"
@@ -323,6 +331,8 @@
 AC_OUTPUT([
 Makefile
 help/Makefile
+libgnome-control-center/Makefile
+libgnome-control-center/libgnome-control-center.pc
 panels/Makefile
 panels/common/Makefile
 panels/background/Makefile
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-editable-entry.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-editable-entry.c	2012-02-21 13:34:43.659097696 +0100
@@ -0,0 +1,546 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright 2009-2010  Red Hat, Inc,
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Written by: Matthias Clasen <mclasen@redhat.com>
+ */
+
+#include <gdk/gdkkeysyms.h>
+#include "cc-editable-entry.h"
+
+#define EMPTY_TEXT "\xe2\x80\x94"
+
+struct _CcEditableEntryPrivate {
+        GtkNotebook *notebook;
+        GtkLabel    *label;
+        GtkButton   *button;
+        GtkEntry    *entry;
+
+        gchar *text;
+        gboolean editable;
+        gboolean selectable;
+        gint weight;
+        gboolean weight_set;
+        gdouble scale;
+        gboolean scale_set;
+
+        gboolean in_stop_editing;
+};
+
+#define CC_EDITABLE_ENTRY_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), CC_TYPE_EDITABLE_ENTRY, CcEditableEntryPrivate))
+
+enum {
+        PROP_0,
+        PROP_TEXT,
+        PROP_EDITABLE,
+        PROP_SELECTABLE,
+        PROP_SCALE,
+        PROP_SCALE_SET,
+        PROP_WEIGHT,
+        PROP_WEIGHT_SET
+};
+
+enum {
+        EDITING_DONE,
+        LAST_SIGNAL
+};
+
+enum {
+        PAGE_LABEL,
+        PAGE_BUTTON,
+        PAGE_ENTRY
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+G_DEFINE_TYPE (CcEditableEntry, cc_editable_entry, GTK_TYPE_ALIGNMENT);
+
+void
+cc_editable_entry_set_text (CcEditableEntry *e,
+                             const gchar    *text)
+{
+        CcEditableEntryPrivate *priv;
+        gchar *tmp;
+        GtkWidget *label;
+
+        priv = e->priv;
+
+        tmp = g_strdup (text);
+        g_free (priv->text);
+        priv->text = tmp;
+
+        gtk_entry_set_text (priv->entry, tmp);
+
+        if (tmp == NULL || tmp[0] == '\0')
+                tmp = EMPTY_TEXT;
+
+        gtk_label_set_text (priv->label, tmp);
+        label = gtk_bin_get_child (GTK_BIN (priv->button));
+        gtk_label_set_text (GTK_LABEL (label), tmp);
+
+        g_object_notify (G_OBJECT (e), "text");
+}
+
+const gchar *
+cc_editable_entry_get_text (CcEditableEntry *e)
+{
+        return e->priv->text;
+}
+
+void
+cc_editable_entry_set_editable (CcEditableEntry *e,
+                                 gboolean        editable)
+{
+        CcEditableEntryPrivate *priv;
+
+        priv = e->priv;
+
+        if (priv->editable != editable) {
+                priv->editable = editable;
+
+                gtk_notebook_set_current_page (priv->notebook, editable ? PAGE_BUTTON : PAGE_LABEL);
+
+                g_object_notify (G_OBJECT (e), "editable");
+        }
+}
+
+gboolean
+cc_editable_entry_get_editable (CcEditableEntry *e)
+{
+        return e->priv->editable;
+}
+
+void
+cc_editable_entry_set_selectable (CcEditableEntry *e,
+                                  gboolean         selectable)
+{
+        CcEditableEntryPrivate *priv;
+
+        priv = e->priv;
+
+        if (priv->selectable != selectable) {
+                priv->selectable = selectable;
+
+                gtk_label_set_selectable (priv->label, selectable);
+
+                g_object_notify (G_OBJECT (e), "selectable");
+        }
+}
+
+gboolean
+cc_editable_entry_get_selectable (CcEditableEntry *e)
+{
+        return e->priv->selectable;
+}
+
+static void
+update_entry_font (GtkWidget        *widget,
+                   CcEditableEntry *e)
+{
+        CcEditableEntryPrivate *priv = e->priv;
+        PangoFontDescription *desc;
+        GtkStyleContext *style;
+        gint size;
+
+        if (!priv->weight_set && !priv->scale_set)
+                return;
+
+        g_signal_handlers_block_by_func (widget, update_entry_font, e);
+
+        gtk_widget_override_font (widget, NULL);        
+
+        style = gtk_widget_get_style_context (widget);
+        desc = pango_font_description_copy 
+                (gtk_style_context_get_font (style, gtk_widget_get_state_flags (widget)));
+
+        if (priv->weight_set)
+                pango_font_description_set_weight (desc, priv->weight);
+        if (priv->scale_set) {
+                size = pango_font_description_get_size (desc);
+                pango_font_description_set_size (desc, priv->scale * size);
+        }
+        gtk_widget_override_font (widget, desc);
+
+        pango_font_description_free (desc);
+
+        g_signal_handlers_unblock_by_func (widget, update_entry_font, e);
+}
+
+static void
+update_fonts (CcEditableEntry *e)
+{
+        PangoAttrList *attrs;
+        PangoAttribute *attr;
+        GtkWidget *label;
+
+        CcEditableEntryPrivate *priv = e->priv;
+
+        attrs = pango_attr_list_new ();
+        if (priv->scale_set) {
+                attr = pango_attr_scale_new (priv->scale);
+                pango_attr_list_insert (attrs, attr);
+        }
+        if (priv->weight_set) {
+                attr = pango_attr_weight_new (priv->weight);
+                pango_attr_list_insert (attrs, attr);
+        }
+
+        gtk_label_set_attributes (priv->label, attrs);
+
+        label = gtk_bin_get_child (GTK_BIN (priv->button));
+        gtk_label_set_attributes (GTK_LABEL (label), attrs);
+
+        pango_attr_list_unref (attrs);
+
+        update_entry_font ((GtkWidget *)priv->entry, e);
+}
+
+void
+cc_editable_entry_set_weight (CcEditableEntry *e,
+                               gint            weight)
+{
+        CcEditableEntryPrivate *priv = e->priv;
+
+        if (priv->weight == weight && priv->weight_set)
+                return;
+
+        priv->weight = weight;
+        priv->weight_set = TRUE;
+
+        update_fonts (e);
+
+        g_object_notify (G_OBJECT (e), "weight");
+        g_object_notify (G_OBJECT (e), "weight-set");
+}
+
+gint
+cc_editable_entry_get_weight (CcEditableEntry *e)
+{
+        return e->priv->weight;
+}
+
+void
+cc_editable_entry_set_scale (CcEditableEntry *e,
+                              gdouble         scale)
+{
+        CcEditableEntryPrivate *priv = e->priv;
+
+        if (priv->scale == scale && priv->scale_set)
+                return;
+
+        priv->scale = scale;
+        priv->scale_set = TRUE;
+
+        update_fonts (e);
+
+        g_object_notify (G_OBJECT (e), "scale");
+        g_object_notify (G_OBJECT (e), "scale-set");
+}
+
+gdouble
+cc_editable_entry_get_scale (CcEditableEntry *e)
+{
+        return e->priv->scale;
+}
+
+static void
+cc_editable_entry_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+        CcEditableEntry *e = CC_EDITABLE_ENTRY (object);
+
+        switch (prop_id) {
+        case PROP_TEXT:
+                cc_editable_entry_set_text (e, g_value_get_string (value));
+                break;
+        case PROP_EDITABLE:
+                cc_editable_entry_set_editable (e, g_value_get_boolean (value));
+                break;
+        case PROP_SELECTABLE:
+                cc_editable_entry_set_selectable (e, g_value_get_boolean (value));
+                break;
+        case PROP_WEIGHT:
+                cc_editable_entry_set_weight (e, g_value_get_int (value));
+                break;
+        case PROP_WEIGHT_SET:
+                e->priv->weight_set = g_value_get_boolean (value);
+                break;
+        case PROP_SCALE:
+                cc_editable_entry_set_scale (e, g_value_get_double (value));
+                break;
+        case PROP_SCALE_SET:
+                e->priv->scale_set = g_value_get_boolean (value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_editable_entry_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+        CcEditableEntry *e = CC_EDITABLE_ENTRY (object);
+
+        switch (prop_id) {
+        case PROP_TEXT:
+                g_value_set_string (value,
+                                    cc_editable_entry_get_text (e));
+                break;
+        case PROP_EDITABLE:
+                g_value_set_boolean (value,
+                                     cc_editable_entry_get_editable (e));
+                break;
+        case PROP_SELECTABLE:
+                g_value_set_boolean (value,
+                                     cc_editable_entry_get_selectable (e));
+                break;
+        case PROP_WEIGHT:
+                g_value_set_int (value,
+                                 cc_editable_entry_get_weight (e));
+                break;
+        case PROP_WEIGHT_SET:
+                g_value_set_boolean (value, e->priv->weight_set);
+                break;
+        case PROP_SCALE:
+                g_value_set_double (value,
+                                    cc_editable_entry_get_scale (e));
+                break;
+        case PROP_SCALE_SET:
+                g_value_set_boolean (value, e->priv->scale_set);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_editable_entry_finalize (GObject *object)
+{
+        CcEditableEntry *e = (CcEditableEntry*)object;
+
+        g_free (e->priv->text);
+
+        G_OBJECT_CLASS (cc_editable_entry_parent_class)->finalize (object);
+}
+
+static void
+cc_editable_entry_class_init (CcEditableEntryClass *class)
+{
+        GObjectClass *object_class;
+
+        object_class = G_OBJECT_CLASS (class);
+
+        object_class->set_property = cc_editable_entry_set_property;
+        object_class->get_property = cc_editable_entry_get_property;
+        object_class->finalize = cc_editable_entry_finalize;
+
+        signals[EDITING_DONE] =
+                g_signal_new ("editing-done",
+                              G_TYPE_FROM_CLASS (class),
+                              G_SIGNAL_RUN_LAST,
+                              G_STRUCT_OFFSET (CcEditableEntryClass, editing_done),
+                              NULL, NULL,
+                              g_cclosure_marshal_VOID__VOID,
+                              G_TYPE_NONE, 0);
+
+        g_object_class_install_property (object_class, PROP_TEXT,
+                g_param_spec_string ("text",
+                                     "Text", "The text of the button",
+                                     NULL,
+                                     G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_EDITABLE,
+                g_param_spec_boolean ("editable",
+                                      "Editable", "Whether the text can be edited",
+                                      FALSE,
+                                      G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_SELECTABLE,
+                g_param_spec_boolean ("selectable",
+                                      "Selectable", "Whether the text can be selected by mouse",
+                                      FALSE,
+                                      G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_WEIGHT,
+                g_param_spec_int ("weight",
+                                  "Font Weight", "The font weight to use",
+                                  0, G_MAXINT, PANGO_WEIGHT_NORMAL,
+                                  G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_WEIGHT_SET,
+                g_param_spec_boolean ("weight-set",
+                                      "Font Weight Set", "Whether a font weight is set",
+                                      FALSE,
+                                      G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_SCALE,
+                g_param_spec_double ("scale",
+                                     "Font Scale", "The font scale to use",
+                                     0.0, G_MAXDOUBLE, 1.0,
+                                     G_PARAM_READWRITE));
+
+        g_object_class_install_property (object_class, PROP_SCALE_SET,
+                g_param_spec_boolean ("scale-set",
+                                      "Font Scale Set", "Whether a font scale is set",
+                                      FALSE,
+                                      G_PARAM_READWRITE));
+
+        g_type_class_add_private (class, sizeof (CcEditableEntryPrivate));
+}
+
+static void
+start_editing (CcEditableEntry *e)
+{
+        gtk_notebook_set_current_page (e->priv->notebook, PAGE_ENTRY);
+}
+
+static void
+stop_editing (CcEditableEntry *e)
+{
+        /* Avoid launching another "editing-done" signal
+         * caused by the notebook page change */
+        if (e->priv->in_stop_editing)
+                return;
+
+        e->priv->in_stop_editing = TRUE;
+        gtk_notebook_set_current_page (e->priv->notebook, PAGE_BUTTON);
+        cc_editable_entry_set_text (e, gtk_entry_get_text (e->priv->entry));
+        g_signal_emit (e, signals[EDITING_DONE], 0);
+        e->priv->in_stop_editing = FALSE;
+}
+
+static void
+cancel_editing (CcEditableEntry *e)
+{
+        gtk_entry_set_text (e->priv->entry, cc_editable_entry_get_text (e));
+        gtk_notebook_set_current_page (e->priv->notebook, PAGE_BUTTON);
+}
+
+static void
+button_clicked (GtkWidget       *widget,
+                CcEditableEntry *e)
+{
+        start_editing (e);
+}
+
+static void
+entry_activated (GtkWidget       *widget,
+                 CcEditableEntry *e)
+{
+        stop_editing (e);
+}
+
+static gboolean
+entry_focus_out (GtkWidget       *widget,
+                 GdkEventFocus   *event,
+                 CcEditableEntry *e)
+{
+        stop_editing (e);
+        return FALSE;
+}
+
+static gboolean
+entry_key_press (GtkWidget       *widget,
+                 GdkEventKey     *event,
+                 CcEditableEntry *e)
+{
+        if (event->keyval == GDK_KEY_Escape) {
+                cancel_editing (e);
+        }
+        return FALSE;
+}
+
+static void
+update_button_padding (GtkWidget       *widget,
+                       GtkAllocation   *allocation,
+                       CcEditableEntry *e)
+{
+        CcEditableEntryPrivate *priv = e->priv;
+        GtkAllocation alloc;
+        gint offset;
+        gint pad;
+
+        gtk_widget_get_allocation (gtk_widget_get_parent (widget), &alloc);
+
+        offset = allocation->x - alloc.x;
+
+        gtk_misc_get_padding  (GTK_MISC (priv->label), &pad, NULL);
+        if (offset != pad)
+                gtk_misc_set_padding (GTK_MISC (priv->label), offset, 0);
+}
+
+static void
+cc_editable_entry_init (CcEditableEntry *e)
+{
+        CcEditableEntryPrivate *priv;
+
+        priv = e->priv = CC_EDITABLE_ENTRY_GET_PRIVATE (e);
+
+        priv->weight = PANGO_WEIGHT_NORMAL;
+        priv->weight_set = FALSE;
+        priv->scale = 1.0;
+        priv->scale_set = FALSE;
+
+        priv->notebook = (GtkNotebook*)gtk_notebook_new ();
+        gtk_notebook_set_show_tabs (priv->notebook, FALSE);
+        gtk_notebook_set_show_border (priv->notebook, FALSE);
+
+        /* Label */
+        priv->label = (GtkLabel*)gtk_label_new (EMPTY_TEXT);
+        gtk_misc_set_alignment (GTK_MISC (priv->label), 0.0, 0.5);
+        gtk_notebook_append_page (priv->notebook, (GtkWidget*)priv->label, NULL);
+
+        /* Button */
+        priv->button = (GtkButton*)gtk_button_new_with_label (EMPTY_TEXT);
+        gtk_widget_set_receives_default ((GtkWidget*)priv->button, TRUE);
+        gtk_button_set_relief (priv->button, GTK_RELIEF_NONE);
+        gtk_button_set_alignment (priv->button, 0.0, 0.5);
+        gtk_notebook_append_page (priv->notebook, (GtkWidget*)priv->button, NULL);
+        g_signal_connect (priv->button, "clicked", G_CALLBACK (button_clicked), e);
+
+        /* Entry */
+        priv->entry = (GtkEntry*)gtk_entry_new ();
+        gtk_notebook_append_page (priv->notebook, (GtkWidget*)priv->entry, NULL);
+
+        g_signal_connect (priv->entry, "activate", G_CALLBACK (entry_activated), e);
+        g_signal_connect (priv->entry, "focus-out-event", G_CALLBACK (entry_focus_out), e);
+        g_signal_connect (priv->entry, "key-press-event", G_CALLBACK (entry_key_press), e);
+        g_signal_connect (priv->entry, "style-updated", G_CALLBACK (update_entry_font), e);
+        g_signal_connect (gtk_bin_get_child (GTK_BIN (priv->button)), "size-allocate", G_CALLBACK (update_button_padding), e);
+
+        gtk_container_add (GTK_CONTAINER (e), (GtkWidget*)priv->notebook);
+
+        gtk_widget_show ((GtkWidget*)priv->notebook);
+        gtk_widget_show ((GtkWidget*)priv->label);
+        gtk_widget_show ((GtkWidget*)priv->button);
+        gtk_widget_show ((GtkWidget*)priv->entry);
+
+        gtk_notebook_set_current_page (priv->notebook, PAGE_LABEL);
+}
+
+GtkWidget *
+cc_editable_entry_new (void)
+{
+        return (GtkWidget *) g_object_new (CC_TYPE_EDITABLE_ENTRY, NULL);
+}
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-editable-entry.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-editable-entry.h	2012-02-21 13:34:43.659097696 +0100
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright 2009-2010  Red Hat, Inc,
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Written by: Matthias Clasen <mclasen@redhat.com>
+ */
+
+#ifndef _CC_EDITABLE_ENTRY_H_
+#define _CC_EDITABLE_ENTRY_H_
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_EDITABLE_ENTRY  cc_editable_entry_get_type()
+
+#define CC_EDITABLE_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CC_TYPE_EDITABLE_ENTRY, CcEditableEntry))
+#define CC_EDITABLE_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CC_TYPE_EDITABLE_ENTRY, CcEditableEntryClass))
+#define CC_IS_EDITABLE_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CC_TYPE_EDITABLE_ENTRY))
+#define CC_IS_EDITABLE_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CC_TYPE_EDITABLE_ENTRY))
+#define CC_EDITABLE_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CC_TYPE_EDITABLE_ENTRY, CcEditableEntryClass))
+
+typedef struct _CcEditableEntry CcEditableEntry;
+typedef struct _CcEditableEntryClass CcEditableEntryClass;
+typedef struct _CcEditableEntryPrivate CcEditableEntryPrivate;
+
+struct _CcEditableEntry
+{
+  GtkAlignment parent;
+
+  CcEditableEntryPrivate *priv;
+};
+
+struct _CcEditableEntryClass
+{
+  GtkAlignmentClass parent_class;
+
+  void (* editing_done) (CcEditableEntry *entry);
+};
+
+GType        cc_editable_entry_get_type       (void) G_GNUC_CONST;
+GtkWidget   *cc_editable_entry_new            (void);
+void         cc_editable_entry_set_text       (CcEditableEntry *entry,
+                                               const gchar     *text);
+const gchar *cc_editable_entry_get_text       (CcEditableEntry *entry);
+void         cc_editable_entry_set_editable   (CcEditableEntry *entry,
+                                               gboolean         editable);
+gboolean     cc_editable_entry_get_editable   (CcEditableEntry *entry);
+void         cc_editable_entry_set_selectable (CcEditableEntry *entry,
+                                               gboolean         selectable);
+gboolean     cc_editable_entry_get_selectable (CcEditableEntry *entry);
+void         cc_editable_entry_set_weight     (CcEditableEntry *entry,
+                                               gint             weight);
+gint         cc_editable_entry_get_weight     (CcEditableEntry *entry);
+void         cc_editable_entry_set_scale      (CcEditableEntry *entry,
+                                               gdouble          scale);
+gdouble      cc_editable_entry_get_scale      (CcEditableEntry *entry);
+
+G_END_DECLS
+
+#endif /* _CC_EDITABLE_ENTRY_H_ */
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-panel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-panel.c	2012-02-21 13:34:43.659097696 +0100
@@ -0,0 +1,248 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ * Copyright (C) 2010 Intel, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: William Jon McCann <jmccann@redhat.com>
+ *          Thomas Wood <thomas.wood@intel.com>
+ *
+ */
+
+/**
+ * SECTION:cc-panel
+ * @short_description: An abstract class for Control Center panels
+ *
+ * CcPanel is an abstract class used to implement panels for the shell. A
+ * panel contains a collection of related settings that are displayed within
+ * the shell window.
+ */
+
+#include "config.h"
+
+#include "cc-panel.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <gtk/gtk.h>
+#include <gio/gio.h>
+
+#define CC_PANEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_PANEL, CcPanelPrivate))
+
+struct CcPanelPrivate
+{
+  gchar    *id;
+  gchar    *display_name;
+  gchar    *category;
+  gchar    *current_location;
+
+  gboolean  is_active;
+  CcShell  *shell;
+};
+
+enum
+{
+    PROP_0,
+    PROP_SHELL,
+    PROP_ARGV
+};
+
+G_DEFINE_ABSTRACT_TYPE (CcPanel, cc_panel, GTK_TYPE_BIN)
+
+static void
+cc_panel_set_property (GObject      *object,
+                       guint         prop_id,
+                       const GValue *value,
+                       GParamSpec   *pspec)
+{
+  CcPanel *panel;
+
+  panel = CC_PANEL (object);
+
+  switch (prop_id)
+    {
+    case PROP_SHELL:
+      /* construct only property */
+      panel->priv->shell = g_value_get_object (value);
+      break;
+
+    case PROP_ARGV:
+      {
+        gchar **argv = g_value_get_boxed (value);
+        if (argv && argv[0])
+          g_warning ("Ignoring additional argument %s", argv[0]);
+        break;
+      }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+cc_panel_get_property (GObject    *object,
+                       guint       prop_id,
+                       GValue     *value,
+                       GParamSpec *pspec)
+{
+  CcPanel *panel;
+
+  panel = CC_PANEL (object);
+
+  switch (prop_id)
+    {
+    case PROP_SHELL:
+      g_value_set_object (value, panel->priv->shell);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+cc_panel_finalize (GObject *object)
+{
+  CcPanel *panel;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (CC_IS_PANEL (object));
+
+  panel = CC_PANEL (object);
+
+  g_free (panel->priv->id);
+  g_free (panel->priv->display_name);
+
+  G_OBJECT_CLASS (cc_panel_parent_class)->finalize (object);
+}
+
+static void
+cc_panel_get_preferred_width (GtkWidget *widget,
+                              gint      *minimum,
+                              gint      *natural)
+{
+  GtkBin *bin = GTK_BIN (widget);
+  GtkWidget *child;
+
+  if (minimum != NULL)
+    *minimum = 0;
+
+  if (natural != NULL)
+    *natural = 0;
+
+  if ((child = gtk_bin_get_child (bin)))
+    gtk_widget_get_preferred_width (child, minimum, natural);
+}
+
+static void
+cc_panel_get_preferred_height (GtkWidget *widget,
+                               gint      *minimum,
+                               gint      *natural)
+{
+  GtkBin *bin = GTK_BIN (widget);
+  GtkWidget *child;
+
+  if (minimum != NULL)
+    *minimum = 0;
+
+  if (natural != NULL)
+    *natural = 0;
+
+  if ((child = gtk_bin_get_child (bin)))
+    gtk_widget_get_preferred_height (child, minimum, natural);
+}
+
+static void
+cc_panel_size_allocate (GtkWidget     *widget,
+                             GtkAllocation *allocation)
+{
+  GtkAllocation child_allocation;
+
+  gtk_widget_set_allocation (widget, allocation);
+
+  child_allocation = *allocation;
+
+  gtk_widget_size_allocate (gtk_bin_get_child (GTK_BIN (widget)),
+                            &child_allocation);
+}
+
+static void
+cc_panel_class_init (CcPanelClass *klass)
+{
+  GParamSpec      *pspec;
+  GObjectClass    *object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass  *widget_class = GTK_WIDGET_CLASS (klass);
+
+  object_class->get_property = cc_panel_get_property;
+  object_class->set_property = cc_panel_set_property;
+  object_class->finalize = cc_panel_finalize;
+
+  widget_class->get_preferred_width = cc_panel_get_preferred_width;
+  widget_class->get_preferred_height = cc_panel_get_preferred_height;
+  widget_class->size_allocate = cc_panel_size_allocate;
+
+  gtk_container_class_handle_border_width (GTK_CONTAINER_CLASS (klass));
+
+  g_type_class_add_private (klass, sizeof (CcPanelPrivate));
+
+  pspec = g_param_spec_object ("shell",
+                               "Shell",
+                               "Shell the Panel resides in",
+                               CC_TYPE_SHELL,
+                               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS
+                               | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_SHELL, pspec);
+
+  pspec = g_param_spec_boxed ("argv",
+                              "Argument vector",
+                              "Additional arguments passed on the command line",
+                              G_TYPE_STRV,
+                              G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_ARGV, pspec);
+}
+
+static void
+cc_panel_init (CcPanel *panel)
+{
+  panel->priv = CC_PANEL_GET_PRIVATE (panel);
+}
+
+/**
+ * cc_panel_get_shell:
+ * @panel: A #CcPanel
+ *
+ * Get the shell that the panel resides in
+ *
+ * Returns: a #CcShell
+ */
+CcShell *
+cc_panel_get_shell (CcPanel *panel)
+{
+  return panel->priv->shell;
+}
+
+GPermission *
+cc_panel_get_permission (CcPanel *panel)
+{
+  CcPanelClass *class = CC_PANEL_GET_CLASS (panel);
+
+  if (class->get_permission)
+    return class->get_permission (panel);
+
+  return NULL;
+}
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-panel.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-panel.h	2012-02-21 13:34:43.659097696 +0100
@@ -0,0 +1,81 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ * Copyright (C) 2010 Intel, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: William Jon McCann <jmccann@redhat.com>
+ *          Thomas Wood <thomas.wood@intel.com>
+ */
+
+
+#ifndef __CC_PANEL_H
+#define __CC_PANEL_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_PANEL         (cc_panel_get_type ())
+#define CC_PANEL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_TYPE_PANEL, CcPanel))
+#define CC_PANEL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), CC_TYPE_PANEL, CcPanelClass))
+#define CC_IS_PANEL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_TYPE_PANEL))
+#define CC_IS_PANEL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), CC_TYPE_PANEL))
+#define CC_PANEL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_TYPE_PANEL, CcPanelClass))
+
+typedef struct CcPanelPrivate CcPanelPrivate;
+
+typedef struct _CcPanel       CcPanel;
+typedef struct _CcPanelClass  CcPanelClass;
+
+/* cc-shell.h requires CcPanel, so make sure it is defined first */
+#include "cc-shell.h"
+
+/**
+ * CcPanel:
+ *
+ * The contents of this struct are private and should not be accessed directly.
+ */
+struct _CcPanel
+{
+  /*< private >*/
+  GtkBin          parent;
+  CcPanelPrivate *priv;
+};
+/**
+ * CcPanelClass:
+ *
+ * The contents of this struct are private and should not be accessed directly.
+ */
+struct _CcPanelClass
+{
+  /*< private >*/
+  GtkBinClass parent_class;
+
+  GPermission * (* get_permission) (CcPanel *panel);
+};
+
+GType        cc_panel_get_type         (void);
+
+CcShell*     cc_panel_get_shell        (CcPanel     *panel);
+
+GPermission *cc_panel_get_permission   (CcPanel     *panel);
+
+G_END_DECLS
+
+#endif /* __CC_PANEL_H */
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-shell.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-shell.c	2012-02-21 13:34:43.663097697 +0100
@@ -0,0 +1,259 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+/**
+ * SECTION:cc-shell
+ * @short_description: Abstract class representing the Control Center shell
+ *
+ * CcShell is an abstract class that represents an instance of a control
+ * center shell. It provides access to some of the properties of the shell
+ * that panels will need to read or change. When a panel is created it has an
+ * instance of CcShell available that represents the current shell.
+ */
+
+
+#include "cc-shell.h"
+#include "cc-panel.h"
+
+G_DEFINE_ABSTRACT_TYPE (CcShell, cc_shell, G_TYPE_OBJECT)
+
+#define SHELL_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_SHELL, CcShellPrivate))
+
+struct _CcShellPrivate
+{
+  CcPanel *active_panel;
+};
+
+enum
+{
+  PROP_ACTIVE_PANEL = 1
+};
+
+
+static void
+cc_shell_get_property (GObject    *object,
+                       guint       property_id,
+                       GValue     *value,
+                       GParamSpec *pspec)
+{
+  CcShell *shell = CC_SHELL (object);
+
+  switch (property_id)
+    {
+    case PROP_ACTIVE_PANEL:
+      g_value_set_object (value, shell->priv->active_panel);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_set_property (GObject      *object,
+                       guint         property_id,
+                       const GValue *value,
+                       GParamSpec   *pspec)
+{
+  CcShell *shell = CC_SHELL (object);
+
+  switch (property_id)
+    {
+    case PROP_ACTIVE_PANEL:
+      cc_shell_set_active_panel (shell, g_value_get_object (value));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_dispose (GObject *object)
+{
+  /* remove and unref the active shell */
+  cc_shell_set_active_panel (CC_SHELL (object), NULL);
+
+  G_OBJECT_CLASS (cc_shell_parent_class)->dispose (object);
+}
+
+static void
+cc_shell_class_init (CcShellClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GParamSpec *pspec;
+
+  g_type_class_add_private (klass, sizeof (CcShellPrivate));
+
+  object_class->get_property = cc_shell_get_property;
+  object_class->set_property = cc_shell_set_property;
+  object_class->dispose = cc_shell_dispose;
+
+  pspec = g_param_spec_object ("active-panel",
+                               "active panel",
+                               "The currently active Panel",
+                               CC_TYPE_PANEL,
+                               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_ACTIVE_PANEL, pspec);
+}
+
+static void
+cc_shell_init (CcShell *self)
+{
+  self->priv = SHELL_PRIVATE (self);
+}
+
+/**
+ * cc_shell_get_active_panel:
+ * @shell: A #CcShell
+ *
+ * Get the current active panel
+ *
+ * Returns: a #CcPanel or NULL if no panel is active
+ */
+CcPanel*
+cc_shell_get_active_panel (CcShell *shell)
+{
+  g_return_val_if_fail (CC_IS_SHELL (shell), NULL);
+
+  return shell->priv->active_panel;
+}
+
+/**
+ * cc_shell_set_active_panel:
+ * @shell: A #CcShell
+ * @panel: A #CcPanel
+ *
+ * Set the current active panel. If @panel is NULL, then the shell is returned
+ * to a state where no panel is being displayed (for example, the list of panels
+ * may be shown instead).
+ *
+ */
+void
+cc_shell_set_active_panel (CcShell *shell,
+                           CcPanel *panel)
+{
+  g_return_if_fail (CC_IS_SHELL (shell));
+  g_return_if_fail (panel == NULL || CC_IS_PANEL (panel));
+
+  if (panel != shell->priv->active_panel)
+    {
+      /* remove the old panel */
+      g_object_unref (shell->priv->active_panel);
+      shell->priv->active_panel = NULL;
+
+      /* set the new panel */
+      if (panel)
+        {
+          shell->priv->active_panel = g_object_ref (panel);
+          g_object_set (G_OBJECT (panel), "shell", shell, NULL);
+        }
+      g_object_notify (G_OBJECT (shell), "active-panel");
+    }
+}
+
+/**
+ * cc_shell_set_active_panel_from_id:
+ * @shell: A #CcShell
+ * @id: the ID of the panel to set as active
+ * @error: A #GError
+ *
+ * Find a panel corresponding to the specified id and set it as active.
+ *
+ * Returns: #TRUE if the panel was found and set as the active panel
+ */
+gboolean
+cc_shell_set_active_panel_from_id (CcShell      *shell,
+                                   const gchar  *id,
+                                   const gchar **argv,
+                                   GError      **error)
+{
+  CcShellClass *class;
+
+  g_return_val_if_fail (CC_IS_SHELL (shell), FALSE);
+
+
+  class = (CcShellClass *) G_OBJECT_GET_CLASS (shell);
+
+  if (!class->set_active_panel_from_id)
+    {
+      g_warning ("Object of type \"%s\" does not implement required virtual"
+                 " function \"set_active_panel_from_id\",",
+                 G_OBJECT_TYPE_NAME (shell));
+      return FALSE;
+    }
+  else
+    {
+      return class->set_active_panel_from_id (shell, id, argv, error);
+    }
+}
+
+/**
+ * cc_shell_get_toplevel:
+ * @shell: A #CcShell
+ *
+ * Gets the toplevel window of the shell.
+ *
+ * Returns: The #GtkWidget of the shell window, or #NULL on error.
+ */
+GtkWidget *
+cc_shell_get_toplevel (CcShell *shell)
+{
+  CcShellClass *klass;
+
+  g_return_val_if_fail (CC_IS_SHELL (shell), NULL);
+
+  klass = CC_SHELL_GET_CLASS (shell);
+
+  if (klass->get_toplevel)
+    {
+        return klass->get_toplevel (shell);
+    }
+
+  g_warning ("Object of type \"%s\" does not implement required virtual"
+             " function \"get_toplevel\",",
+             G_OBJECT_TYPE_NAME (shell));
+
+  return NULL;
+}
+
+void
+cc_shell_embed_widget_in_header (CcShell *shell, GtkWidget *widget)
+{
+  CcShellClass *class;
+
+  g_return_if_fail (CC_IS_SHELL (shell));
+
+  class = (CcShellClass *) G_OBJECT_GET_CLASS (shell);
+
+  if (!class->embed_widget_in_header)
+    {
+      g_warning ("Object of type \"%s\" does not implement required virtual"
+                 " function \"embed_widget_in_header\",",
+                 G_OBJECT_TYPE_NAME (shell));
+      return FALSE;
+    }
+  else
+    {
+      return class->embed_widget_in_header (shell, widget);
+    }
+}
Index: gnome-control-center-3.3.90/libgnome-control-center/cc-shell.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/cc-shell.h	2012-02-21 13:34:43.663097697 +0100
@@ -0,0 +1,112 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#ifndef _CC_SHELL_H
+#define _CC_SHELL_H
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SHELL cc_shell_get_type()
+
+#define CC_SHELL(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CC_TYPE_SHELL, CcShell))
+
+#define CC_SHELL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CC_TYPE_SHELL, CcShellClass))
+
+#define CC_IS_SHELL(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CC_TYPE_SHELL))
+
+#define CC_IS_SHELL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CC_TYPE_SHELL))
+
+#define CC_SHELL_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CC_TYPE_SHELL, CcShellClass))
+
+
+#define CC_SHELL_PANEL_EXTENSION_POINT "control-center-1"
+
+typedef struct _CcShell CcShell;
+typedef struct _CcShellClass CcShellClass;
+typedef struct _CcShellPrivate CcShellPrivate;
+
+/* cc-panel.h requires CcShell, so make sure they are defined first */
+#include "cc-panel.h"
+
+/**
+ * CcShell:
+ *
+ * The contents of this struct are private should not be accessed directly.
+ */
+struct _CcShell
+{
+  /*< private >*/
+  GObject parent;
+
+  CcShellPrivate *priv;
+};
+
+/**
+ * CcShellClass:
+ * @set_active_panel_from_id: virtual function to set the active panel from an
+ *                            id string
+ *
+ */
+struct _CcShellClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /*< public >*/
+  /* vfuncs */
+  gboolean    (*set_active_panel_from_id) (CcShell      *shell,
+                                           const gchar  *id,
+                                           const gchar **argv,
+                                           GError      **error);
+  GtkWidget * (*get_toplevel)             (CcShell      *shell);
+  void        (*embed_widget_in_header)   (CcShell      *shell,
+                                           GtkWidget    *widget);
+};
+
+GType           cc_shell_get_type                 (void) G_GNUC_CONST;
+
+CcPanel*        cc_shell_get_active_panel         (CcShell      *shell);
+void            cc_shell_set_active_panel         (CcShell      *shell,
+                                                   CcPanel      *panel);
+gboolean        cc_shell_set_active_panel_from_id (CcShell      *shell,
+                                                   const gchar  *id,
+                                                   const gchar **argv,
+                                                   GError      **error);
+GtkWidget *     cc_shell_get_toplevel             (CcShell      *shell);
+
+void            cc_shell_embed_widget_in_header   (CcShell      *shell,
+                                                   GtkWidget    *widget);
+
+G_END_DECLS
+
+#endif /* _CC_SHELL_H */
Index: gnome-control-center-3.3.90/libgnome-control-center/libgnome-control-center.pc.in
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/libgnome-control-center.pc.in	2012-02-21 13:34:43.663097697 +0100
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+extensiondir=@libdir@/control-center-1/panels
+
+Name: libgnome-control-center
+Description: A library to create GNOME Control Center extensions
+Version: @VERSION@
+Requires: glib-2.0 gio-2.0 gtk+-3.0
+Libs: -L${libdir} -lgnome-control-center
+Cflags: -I${includedir}/gnome-control-center-1
Index: gnome-control-center-3.3.90/libgnome-control-center/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gnome-control-center-3.3.90/libgnome-control-center/Makefile.am	2012-02-21 13:34:43.663097697 +0100
@@ -0,0 +1,48 @@
+NULL =
+
+uidir = $(pkgdatadir)/ui
+
+AM_CPPFLAGS =					\
+	$(LIBGNOME_CONTROL_CENTER_CFLAGS)	\
+	-DGNOMELOCALEDIR="\"$(datadir)/locale\""\
+	-DUIDIR="\"$(uidir)\""			\
+	-DMENUDIR="\"$(menudir)\""		\
+	$(NULL)
+
+lib_LTLIBRARIES = libgnome-control-center.la
+
+libgnome_control_center_include_HEADERS =      \
+	cc-panel.h                              \
+	cc-shell.h                              \
+	$(NULL)
+
+libgnome_control_center_la_SOURCES =		\
+	cc-panel.c				\
+	cc-panel.h				\
+	cc-shell.c				\
+	cc-shell.h				\
+	cc-editable-entry.c			\
+	cc-editable-entry.h			\
+	$(NULL)
+
+libgnome_control_center_la_LDFLAGS =		\
+	-no-undefined				\
+	-version-info $(LIBGNOMECONTROLCENTER_CURRENT):$(LIBGNOMECONTROLCENTER_REVISION):$(LIBGNOMECONTROLCENTER_AGE) \
+	$(NULL)
+
+libgnome_control_center_la_LIBADD = 		\
+	$(LIBGNOME_CONTROL_CENTER_LIBS)		\
+	$(NULL)
+
+libgnome_control_center_la_LIBTOOLFLAGS = --tag=disable-static
+
+libgnome_control_center_includedir = $(includedir)/gnome-control-center-1/libgnome-control-center
+
+pkgconfigdir=$(libdir)/pkgconfig
+pkgconfig_DATA=libgnome-control-center.pc
+
+EXTRA_DIST =                                   \
+	libgnome-control-center.pc.in  \
+	$(NULL)
+
+-include $(top_srcdir)/git.mk
Index: gnome-control-center-3.3.90/Makefile.am
===================================================================
--- gnome-control-center-3.3.90.orig/Makefile.am	2012-02-20 11:22:59.000000000 +0100
+++ gnome-control-center-3.3.90/Makefile.am	2012-02-21 13:34:43.663097697 +0100
@@ -1,7 +1,7 @@
 ACLOCAL_AMFLAGS = -I m4 ${ACLOCAL_FLAGS}
 
-SUBDIRS = po shell panels help
-DIST_SUBDIRS = po help shell panels
+SUBDIRS = po libgnome-control-center shell panels help
+DIST_SUBDIRS = po help shell panels libgnome-control-center
 
 DISTCLEANFILES = \
 	gnome-doc-utils.make
Index: gnome-control-center-3.3.90/panels/common/Makefile.am
===================================================================
--- gnome-control-center-3.3.90.orig/panels/common/Makefile.am	2012-02-20 11:22:59.000000000 +0100
+++ gnome-control-center-3.3.90/panels/common/Makefile.am	2012-02-21 13:34:43.667097697 +0100
@@ -23,9 +23,10 @@
 	cc-language-chooser.h
 
 liblanguage_la_LIBADD = 		\
+	$(PANEL_LIBS)			    \
 	$(LIBLANGUAGE_LIBS)
 
-liblanguage_la_LDFLAGS = -export_dynamic -avoid-version -module -no-undefined
+liblanguage_la_LDFLAGS = $(PANEL_LDFLAGS)
 
 list_languages_SOURCES = list-languages.c
 list_languages_LDADD = liblanguage.la
Index: gnome-control-center-3.3.90/shell/gnome-control-center.h
===================================================================
--- gnome-control-center-3.3.90.orig/shell/gnome-control-center.h	2012-02-20 11:22:59.000000000 +0100
+++ gnome-control-center-3.3.90/shell/gnome-control-center.h	2012-02-21 13:34:43.667097697 +0100
@@ -22,7 +22,7 @@
 #define _GNOME_CONTROL_CENTER_H
 
 #include <glib-object.h>
-#include "cc-shell.h"
+#include <libgnome-control-center/cc-shell.h>
 
 G_BEGIN_DECLS
 
Index: gnome-control-center-3.3.90/shell/Makefile.am
===================================================================
--- gnome-control-center-3.3.90.orig/shell/Makefile.am	2012-02-21 13:34:43.507097690 +0100
+++ gnome-control-center-3.3.90/shell/Makefile.am	2012-02-21 13:34:43.667097697 +0100
@@ -1,5 +1,6 @@
 INCLUDES =					\
 	-I$(top_srcdir)				\
+	-I$(top_srcdir)/libgnome-control-center \
 	$(SHELL_CFLAGS)
 
 bin_PROGRAMS = gnome-control-center
@@ -29,17 +30,12 @@
 	cc-shell-model.h			\
 	cc-shell-nav-bar.c			\
 	cc-shell-nav-bar.h			\
-	cc-editable-entry.c			\
-	cc-editable-entry.h			\
 	cc-strength-bar.c			\
 	cc-strength-bar.h			\
-	cc-panel.c				\
-	cc-panel.h				\
-	cc-shell.c				\
-	cc-shell.h				\
 	$(MARSHAL_FILES)
 
 gnome_control_center_LDADD =			\
+   $(top_builddir)/libgnome-control-center/libgnome-control-center.la \
 	$(SHELL_LIBS)
 
 gnome_control_center_LDFLAGS = -export-dynamic
Index: gnome-control-center-3.3.90/shell/gnome-control-center.c
===================================================================
--- gnome-control-center-3.3.90.orig/shell/gnome-control-center.c	2012-02-21 13:34:43.535097691 +0100
+++ gnome-control-center-3.3.90/shell/gnome-control-center.c	2012-02-21 13:34:43.667097697 +0100
@@ -202,7 +202,23 @@
         }
       else
         {
-          g_warning ("Could not find the loadable module for panel '%s'", id);
+	  GKeyFile *key_file;
+
+	  /* It might be an external panel */
+	  key_file = g_key_file_new ();
+	  if (g_key_file_load_from_file (key_file, desktop_file, G_KEY_FILE_NONE, NULL))
+	    {
+	      gchar *command;
+
+	      command = g_key_file_get_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_EXEC, NULL);
+	      if (command && command[0])
+	        {
+		  g_spawn_command_line_async (command, NULL);
+		  g_free (command);
+		}
+	    }
+
+	  g_key_file_free (key_file);
         }
     }
 }
