diff -Nur -x '*.orig' -x '*~' gnome-control-center-2.25.3/capplets/display/xrandr-capplet.c gnome-control-center-2.25.3.new/capplets/display/xrandr-capplet.c
--- gnome-control-center-2.25.3/capplets/display/xrandr-capplet.c	2009-01-06 10:55:11.000000000 +0100
+++ gnome-control-center-2.25.3.new/capplets/display/xrandr-capplet.c	2009-01-06 10:56:03.000000000 +0100
@@ -35,6 +35,7 @@
 #include <gconf/gconf-client.h>
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-bindings.h>
+#include "screen-package.h"
 
 typedef struct App App;
 typedef struct GrabInfo GrabInfo;
@@ -83,6 +84,64 @@
     gtk_widget_destroy (dialog);
 }
 
+static void
+show_error_dialog (gchar *info)
+{
+    if (!info)
+	return;
+    
+    GtkWidget *dialog = gtk_message_dialog_new (
+	NULL,
+	GTK_DIALOG_DESTROY_WITH_PARENT,
+	GTK_MESSAGE_ERROR,
+	GTK_BUTTONS_OK, "%s", info);
+    
+    gtk_window_set_title (GTK_WINDOW (dialog), "");
+    
+    gtk_dialog_run (GTK_DIALOG (dialog));
+    gtk_widget_destroy (dialog);
+}
+
+static void
+show_info_dialog (gchar *info)
+{
+    if (!info)
+	return;
+    
+    GtkWidget *dialog = gtk_message_dialog_new (
+	NULL,
+	GTK_DIALOG_DESTROY_WITH_PARENT,
+	GTK_MESSAGE_INFO,
+	GTK_BUTTONS_OK, "%s", info);
+    
+    gtk_window_set_title (GTK_WINDOW (dialog), "");
+    
+    gtk_dialog_run (GTK_DIALOG (dialog));
+    gtk_widget_destroy (dialog);
+}
+
+static gint
+show_question_dialog (gchar *question)
+{
+    if (!question)
+	return;
+    
+    GtkWidget *dialog = gtk_message_dialog_new (
+	NULL,
+	GTK_DIALOG_DESTROY_WITH_PARENT,
+	GTK_MESSAGE_WARNING,
+	GTK_BUTTONS_YES_NO, "%s", question);
+    
+    gtk_window_set_title (GTK_WINDOW (dialog), "");
+    
+    gint response = gtk_dialog_run (GTK_DIALOG (dialog));
+    
+    gtk_widget_destroy (dialog);
+    
+    return response;
+}
+
+
 static gboolean
 do_free (gpointer data)
 {
@@ -1552,39 +1611,14 @@
     }
 }
 
-static void
-compute_virtual_size_for_configuration (GnomeRRConfig *config, int *ret_width, int *ret_height)
-{
-    int i;
-    int width, height;
-
-    width = height = 0;
-
-    for (i = 0; config->outputs[i] != NULL; i++)
-    {
-	GnomeOutputInfo *output;
-
-	output = config->outputs[i];
-
-	if (output->on)
-	{
-	    width = MAX (width, output->x + output->width);
-	    height = MAX (height, output->y + output->height);
-	}
-    }
-
-    *ret_width = width;
-    *ret_height = height;
-}
-
-static void
+static gboolean
 check_required_virtual_size (App *app)
 {
     int req_width, req_height;
     int min_width, max_width;
     int min_height, max_height;
 
-    compute_virtual_size_for_configuration (app->current_configuration, &req_width, &req_height);
+    ubuntu_compute_virtual_size_for_configuration (app->current_configuration, &req_width, &req_height);
 
     gnome_rr_screen_get_ranges (app->screen, &min_width, &max_width, &min_height, &max_height);
 
@@ -1599,11 +1633,116 @@
     if (!(min_width <= req_width && req_width <= max_width
 	  && min_height <= req_height && req_height <= max_height))
     {
-	/* FIXME: present a useful dialog, maybe even before the user tries to Apply */
 #if 0
 	g_debug ("Your X server needs a larger Virtual size!");
 #endif
+        
+        /* Save the desired settings here since, if the 
+         * framebuffer is not enough, the settings won't be
+         * saved to monitor.xml
+         */
+        GError *err = NULL;
+        gnome_rr_config_sanitize (app->current_configuration);
+        
+        /* try to save the desired settings even though the
+         * current framebuffer size is not enough
+         */
+        ubuntu_gnome_rr_config_save_desired (app->current_configuration, &err);
+        
+        /* If the Python program is available, we try to
+         * set the virtual resolution, otherwise we simply
+         * show a dialog and inform the user to do it
+         * manually
+         */
+        char *filename = "/usr/share/screen-resolution-extra/policyui.py";
+        gchar *error = _("Your settings cannot be applied because the virtual resolution in not big enough to contain your screens");
+        
+        if ((g_file_test(filename, G_FILE_TEST_EXISTS)))
+        {
+            /* Send req_width and req_height to the Python program
+             * and it should set the virtual resolution.
+             * The Python program will have a normal exit status
+             * in the following cases:
+             *   1. If the virtual resolution is already set and 
+             *      its size is >= the required size
+             *   2. If the virtual resolution can be set without
+             *      problems
+             * the Python program will exit with an error status if:
+             *   1. for several reasons the virtual resolution can't
+             *      be set (e.g. PolicyKit can't get the authorisation
+             *      or if there's a bug)
+             */
+            gboolean rc;
+            int status;
+            gchar *command = g_strconcat ("python ", filename, NULL);
+            
+            gchar *ostr = g_strdup_printf (" %dx%d", req_width, req_height);
+            gchar *buf = g_strconcat (command, ostr, NULL);
+            g_free(command);
+            g_free(ostr);
+            command = buf;
+            
+            
+            rc = (g_spawn_command_line_sync (command, NULL, NULL, &status, NULL) && status == 0);
+            g_free (command);
+            
+            /* rc is FALSE if the virtual resolution can't be set
+             */
+            if (! rc)
+            {
+                /* inform the user with an error dialog */
+                show_error_dialog (error);
+                /* g_free(error); */
+            }
+            else
+            {
+                /* Operation Complete.
+                 * Inform the user with a dialog
+                 */
+                gchar *info = _("Please log out and log back in again");
+                show_info_dialog(info);
+            }
+        }
+        else
+        {
+            /* ask the user to install screen-resolution-extra */
+            gchar *question = g_strdup_printf (_("The installation of an additional component (%s) is required in order to apply your settings. Would you like to install it now?"), "screen-resolution-extra"); /* screen-resolution-extra mustn't be translated */
+            gint reply = show_question_dialog (question);
+            g_free(question);
+            
+            if (reply != -8)
+            {
+                /* inform the user with an error dialog */
+                show_error_dialog (error);
+            }
+            else
+            {
+                gchar **packages;
+                gboolean installed;
+                gint i = 0;
+                
+                packages = g_new0 (gchar*, 3);
+                
+                packages[i++] = g_strdup ("screen-resolution-extra");
+                
+                installed = ubuntu_packages_install (GTK_WINDOW (app->dialog), packages);
+                g_strfreev (packages);
+                
+                if (installed)
+                {
+                    /* screen-resolution-extra was installed.
+                     * Call this function again so as to use screen-resolution-extra.
+                     */
+                    gboolean result = check_required_virtual_size (app);
+                    return result;
+                }
+                
+            }
+        }
+        return FALSE;
     }
+    else
+        return TRUE;
 }
 
 static void
@@ -1615,41 +1754,47 @@
 
     gnome_rr_config_sanitize (app->current_configuration);
 
-    check_required_virtual_size (app);
-
-    foo_scroll_area_invalidate (FOO_SCROLL_AREA (app->area));
+    /* Don't try to apply the settings unless the framebuffer
+     * is enough. The user will be notified in 
+     * check_required_virtual_size()
+     */
+    if (app->current_configuration->clone || check_required_virtual_size (app))
 
-    if (!gnome_rr_config_save (app->current_configuration, &error))
     {
-	error_message (app, _("Could not save the monitor configuration"), error->message);
-	g_error_free (error);
-	return;
-    }
+    foo_scroll_area_invalidate (FOO_SCROLL_AREA (app->area));
+    
+        if (!gnome_rr_config_save (app->current_configuration, &error))
+        {
+            error_message (app, _("Could not save the monitor configuration"), error->message);
+            g_error_free (error);
+            return;
+        }
+
+        connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+        if (connection == NULL) {
+	    error_message (app, _("Could not get session bus while applying display configuration"), error->message);
+	    g_error_free (error);
+	    return;
+        }
 
-    connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
-    if (connection == NULL) {
-	error_message (app, _("Could not get session bus while applying display configuration"), error->message);
-	g_error_free (error);
-	return;
-    }
+        proxy = dbus_g_proxy_new_for_name (connection,
+    				       "org.gnome.SettingsDaemon",
+    				       "/org/gnome/SettingsDaemon/XRANDR",
+     				       "org.gnome.SettingsDaemon.XRANDR");
+        if (!proxy) {
+	    error_message (app, _("Could not get org.gnome.SettingsDaemon.XRANDR"), NULL);
+	    return;
 
-    proxy = dbus_g_proxy_new_for_name (connection,
-				       "org.gnome.SettingsDaemon",
-				       "/org/gnome/SettingsDaemon/XRANDR",
-				       "org.gnome.SettingsDaemon.XRANDR");
-    if (!proxy) {
-	error_message (app, _("Could not get org.gnome.SettingsDaemon.XRANDR"), NULL);
-	return;
+        }
 
-    }
+        if (!dbus_g_proxy_call (proxy, "ApplyConfiguration", &error, G_TYPE_INVALID, G_TYPE_INVALID)) {
+	    error_message (app, _("Could not apply the selected configuration"), error->message);
+	    g_error_free (error);
+        }
 
-    if (!dbus_g_proxy_call (proxy, "ApplyConfiguration", &error, G_TYPE_INVALID, G_TYPE_INVALID)) {
-	error_message (app, _("Could not apply the selected configuration"), error->message);
-	g_error_free (error);
+        g_object_unref (proxy);
+        dbus_g_connection_unref (connection);
     }
-
-    g_object_unref (proxy);
-    dbus_g_connection_unref (connection);
 }
 
 #if 0
