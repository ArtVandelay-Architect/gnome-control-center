=== modified file 'capplets/network/gnome-network-preferences.c'
diff -Nur -x '*.orig' -x '*~' gnome-control-center-2.25.2/capplets/network/gnome-network-preferences.c gnome-control-center-2.25.2.new/capplets/network/gnome-network-preferences.c
--- gnome-control-center-2.25.2/capplets/network/gnome-network-preferences.c	2008-12-17 15:34:57.000000000 +0100
+++ gnome-control-center-2.25.2.new/capplets/network/gnome-network-preferences.c	2008-12-17 15:35:01.000000000 +0100
@@ -28,6 +28,7 @@
 #include <gconf/gconf-client.h>
 #include <glade/glade.h>
 #include <glib/gi18n.h>
+#include <dbus/dbus-glib.h>
 
 #include "capplet-util.h"
 #include "gconf-property-editor.h"
@@ -181,6 +182,246 @@
 	}
 }
 
+static gboolean 
+dbus_set_proxy_helper(DBusGProxy *dbus_proxy, 
+		      const char *proxy_type, 
+		      const char *host, 
+		      int port)
+{
+   GError *error = NULL;
+   gboolean dbus_ret, res;
+   gchar *proxy_str = NULL;
+
+   fprintf(stderr, "set_proxy_helper: '%s' '%s'\n", proxy_type, host);
+
+   /* FIXME: add proxy auth support when a "secure" store for the proxy
+      password is available */
+   proxy_str = g_strdup_printf("%s://%s:%i/", proxy_type, host, port);
+   g_print("p: %s\n", proxy_str);
+
+   dbus_ret = dbus_g_proxy_call (dbus_proxy, "set_proxy", &error, 
+				 G_TYPE_STRING, proxy_type,
+				 G_TYPE_STRING, proxy_str,
+				 G_TYPE_INVALID,
+				 G_TYPE_BOOLEAN, &res, 
+				 G_TYPE_INVALID);
+
+   if(!dbus_ret) {
+      if (error->domain == DBUS_GERROR && 
+	  error->code == DBUS_GERROR_REMOTE_EXCEPTION)
+	 g_printerr ("Caught remote method exception %s: %s",
+		     dbus_g_error_get_name (error),
+		     error->message);
+      else
+	 g_printerr ("Error: %s\n", error->message);
+      g_error_free (error);
+      return FALSE;
+   }
+   g_print("set_proxy() returned: %i\n", res);
+   return TRUE;
+}
+
+static gboolean
+dbus_reset_proxy_helper(DBusGProxy *dbus_proxy, const char *proxy_type)
+{
+   GError *error = NULL;
+   gboolean dbus_ret, res;
+
+   fprintf(stderr, "reseting proxy %s\n", proxy_type);
+
+   dbus_ret = dbus_g_proxy_call (dbus_proxy, "set_proxy", &error, 
+				 G_TYPE_STRING, proxy_type,
+				 G_TYPE_STRING, "",
+				 G_TYPE_INVALID,
+				 G_TYPE_BOOLEAN, &res, 
+				 G_TYPE_INVALID);
+   fprintf(stderr, "reset_proxy() returned: %i\n", res);
+
+   if(!dbus_ret) 
+   {
+      if (error->domain == DBUS_GERROR && 
+	  error->code == DBUS_GERROR_REMOTE_EXCEPTION)
+	 g_printerr ("Caught remote method exception %s: %s",
+		     dbus_g_error_get_name (error),
+		     error->message);
+      else
+	 g_printerr ("Error: %s\n", error->message);
+      g_error_free (error);
+      return FALSE;
+   }
+   return TRUE;
+}
+
+static gboolean
+dbus_set_to_system_gconf_helper(DBusGProxy *dbus_proxy)
+{
+   GConfClient *client;
+   GError *error = NULL;
+   gboolean dbus_ret;
+   gchar* include[] = {"/system/proxy","/system/http_proxy", NULL};
+   gchar* exclude[] = {NULL};
+
+   fprintf(stderr, "set_set_to_system_gconf_helper\n");
+   
+   client = gconf_client_get_default ();
+   gconf_client_suggest_sync (client, &error);
+   dbus_ret = dbus_g_proxy_call (dbus_proxy, "SetSystem", &error,
+				 G_TYPE_STRV, include,
+				 G_TYPE_STRV, exclude,
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+
+   if(!dbus_ret) {
+      if (error->domain == DBUS_GERROR &&
+	  error->code == DBUS_GERROR_REMOTE_EXCEPTION)
+        g_printerr ("Caught remote method exception %s: %s",
+                    dbus_g_error_get_name (error),
+                    error->message);
+      else
+        g_printerr ("Error: %s\n", error->message);
+      g_error_free (error);
+      return FALSE;
+   }
+   return TRUE;
+}
+
+static void
+cb_reset_system_default (GtkButton *button, gpointer data)
+{
+   GConfClient *client;
+   GError *error;
+   gboolean res;
+
+   client = gconf_client_get_default ();
+   res = gconf_client_recursive_unset (client, "/system/proxy", 0, &error);
+   if(!res)
+      g_printerr("recursive_unset: %s", dbus_g_error_get_name(error), error->message);
+   res = gconf_client_recursive_unset (client, "/system/http_proxy", 0, &error);
+   if(!res)
+      g_printerr("recursive_unset: %s", dbus_g_error_get_name(error), error->message);
+}
+
+static void
+cb_make_system_default (GtkButton *button, gpointer data)
+{
+   DBusGConnection *systembus, *sessionbus;
+   GError *error = NULL;
+   DBusGProxy *dbus_proxy;
+   GConfClient *client;
+   gchar *http_proxy, *proxy_str, *ftp_proxy, *https_proxy;
+   gint http_port, ftp_port, https_port;
+   gboolean use_proxy;
+   gboolean res;
+
+   GladeXML *dialog = (GladeXML *) data;
+   g_print ("cb_make_system_default\n");
+
+   // do ride the dbus
+   sessionbus = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+   if (sessionbus == NULL) {
+      g_printerr ("Failed to open connection to bus: %s\n",
+                  error->message);
+      g_error_free (error);
+      return;
+   }
+
+   dbus_proxy = dbus_g_proxy_new_for_name (sessionbus,
+				      "org.freedesktop.PolicyKit.AuthenticationAgent",
+				      "/",
+				      "org.freedesktop.PolicyKit.AuthenticationAgent");
+   if (dbus_proxy == NULL) {
+      g_printerr ("Failed to get proxy: %s\n",
+                  error->message);
+      g_error_free (error);
+      return;
+   }
+
+   if (!dbus_g_proxy_call (dbus_proxy, "ObtainAuthorization", &error, 
+			   G_TYPE_STRING, "org.gnome.gconf.defaults.set-system",
+			   G_TYPE_UINT, 0,
+			   G_TYPE_UINT, getpid(),
+			   G_TYPE_INVALID,
+			   G_TYPE_BOOLEAN, &res, G_TYPE_INVALID))
+      {
+	 if (error->domain == DBUS_GERROR && 
+	     error->code == DBUS_GERROR_REMOTE_EXCEPTION)
+	    g_printerr ("Caught remote method exception %s: %s",
+			dbus_g_error_get_name (error),
+			error->message);
+	 else
+	    g_printerr ("Error: %s\n", error->message);
+	 g_error_free (error);
+	 return;
+      }
+   g_object_unref(dbus_proxy);
+   g_print("ObtainAuth returned: %i\n", res);
+   // so we get a "0" here too if the auth is not required ?!?
+   //   if(!res)
+   //   return;
+   
+   // if we make it to this point, we have authorization to set the proxy
+   systembus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+   dbus_proxy = dbus_g_proxy_new_for_name (systembus,
+				      "com.ubuntu.SystemService",
+				      "/",
+				      "com.ubuntu.SystemService");
+   if (dbus_proxy == NULL) {
+      g_printerr ("Failed to get proxy: %s\n",
+                  error->message);
+      g_error_free (error);
+      return;
+   }
+   client = gconf_client_get_default ();
+   use_proxy = gconf_client_get_bool (client, USE_PROXY_KEY, NULL);
+   
+   if (use_proxy) {
+      // read the proxy settings
+      http_proxy = gconf_client_get_string (client, HTTP_PROXY_HOST_KEY, NULL);
+      http_port = gconf_client_get_int (client, HTTP_PROXY_PORT_KEY, NULL);
+      if(http_proxy == NULL || strlen(http_proxy) == 0)
+	 dbus_reset_proxy_helper(dbus_proxy, "http");
+      else
+	 dbus_set_proxy_helper(dbus_proxy, "http", http_proxy, http_port);
+      
+      ftp_proxy = gconf_client_get_string (client, FTP_PROXY_HOST_KEY, NULL);
+      ftp_port = gconf_client_get_int (client, FTP_PROXY_PORT_KEY, NULL);
+      if(ftp_proxy == NULL || strlen(ftp_proxy) == 0)
+	 dbus_reset_proxy_helper(dbus_proxy, "ftp");
+      else
+	 dbus_set_proxy_helper(dbus_proxy, "ftp", ftp_proxy, ftp_port);
+
+      https_proxy = gconf_client_get_string (client, SECURE_PROXY_HOST_KEY, NULL);
+      https_port = gconf_client_get_int (client, SECURE_PROXY_PORT_KEY, NULL);
+      if(https_proxy == NULL || strlen(https_proxy) == 0)
+	 dbus_reset_proxy_helper(dbus_proxy, "https");
+      else
+	 dbus_set_proxy_helper(dbus_proxy, "https", https_proxy, https_port);
+      g_object_unref(dbus_proxy);
+   } else {
+      // we don't use a proxy
+      dbus_reset_proxy_helper(dbus_proxy, "http");
+      dbus_reset_proxy_helper(dbus_proxy, "ftp");
+      dbus_reset_proxy_helper(dbus_proxy, "https");
+   }
+
+
+   // set it to gconf as well
+   dbus_proxy = dbus_g_proxy_new_for_name (systembus,
+				      "org.gnome.GConf.Defaults",
+				      "/",
+				      "org.gnome.GConf.Defaults");
+   if (dbus_proxy == NULL) {
+      g_printerr ("Failed to get proxy: %s\n",
+                  error->message);
+      g_error_free (error);
+      return;
+   }
+   dbus_set_to_system_gconf_helper(dbus_proxy);
+
+   g_object_unref(dbus_proxy);
+}
+
+
 static void
 cb_dialog_response (GtkDialog *dialog, gint response_id)
 {
@@ -1072,7 +1313,6 @@
 
 	mode_type = g_enum_register_static ("NetworkPreferencesProxyType",
 				            proxytype_values);
-
 	/* There's a bug in peditors that cause them to not initialize the entry
 	 * correctly. */
 	client = gconf_client_get_default ();
@@ -1168,7 +1408,7 @@
 	peditor = GCONF_PROPERTY_EDITOR (gconf_peditor_new_integer (
 			NULL, SOCKS_PROXY_PORT_KEY, WID ("socks_port_spinbutton"),
 			NULL));
-
+	
 	/* Set the proxy entries insensitive if we are using the same proxy for all */
 	if (gconf_client_get_bool (client, USE_SAME_PROXY_KEY, NULL))
 	{
@@ -1203,6 +1443,12 @@
 						G_CALLBACK (cb_add_url), dialog);
 	g_signal_connect (WID ("button_remove_url"), "clicked",
 						G_CALLBACK (cb_remove_url), dialog);
+
+	/* System-wide default */
+	g_signal_connect(WID("button_make_system_default"), "clicked",
+			 G_CALLBACK(cb_make_system_default), dialog);
+	g_signal_connect(WID("button_reset_to_defaults"), "clicked",
+			 G_CALLBACK(cb_reset_system_default), dialog);
 }
 
 int
diff -Nur -x '*.orig' -x '*~' gnome-control-center-2.25.2/capplets/network/gnome-network-preferences.glade gnome-control-center-2.25.2.new/capplets/network/gnome-network-preferences.glade
--- gnome-control-center-2.25.2/capplets/network/gnome-network-preferences.glade	2008-12-17 15:34:57.000000000 +0100
+++ gnome-control-center-2.25.2.new/capplets/network/gnome-network-preferences.glade	2008-12-17 15:36:01.000000000 +0100
@@ -832,6 +832,44 @@
 		  <property name="fill">True</property>
 		</packing>
 	      </child>
+
+
+                <child>
+                  <widget class="GtkHButtonBox" id="hbuttonbox1">
+                    <property name="visible">True</property>
+                    <property name="spacing">6</property>
+                    <property name="layout_style">GTK_BUTTONBOX_START</property>
+                    <child>
+                      <widget class="GtkButton" id="button_make_system_default">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">True</property>
+                        <property name="label" translatable="yes">Apply System-Wide...</property>
+                        <property name="response_id">0</property>
+                      </widget>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <widget class="GtkButton" id="button_reset_to_defaults">
+                        <property name="visible">True</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">True</property>
+                        <property name="label" translatable="yes">Reset</property>
+                        <property name="response_id">0</property>
+                      </widget>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="fill">False</property>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </widget>
+                </child>
+
+
 	    </widget>
 	    <packing>
 	      <property name="tab_expand">False</property>
