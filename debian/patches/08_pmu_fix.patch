diff -aur control-center-2.8.1.vanilla/gnome-settings-daemon/actions/acme-fb-level.c control-center-2.8.1/gnome-settings-daemon/actions/acme-fb-level.c
--- control-center-2.8.1.vanilla/gnome-settings-daemon/actions/acme-fb-level.c	2005-01-25 22:04:12.000000000 +0100
+++ control-center-2.8.1/gnome-settings-daemon/actions/acme-fb-level.c	2005-01-25 22:17:30.000000000 +0100
@@ -31,6 +31,7 @@
 #include <linux/fb.h>
 #include <linux/pmu.h>
 #include <errno.h>
+#include <libgnome/gnome-i18n.h>
 
 #ifndef FBIOBLANK
 #define FBIOBLANK      0x4611          /* 0 or vesa-level+1 */
@@ -84,6 +85,17 @@
 	return;
 }
 
+GQuark
+acme_fblevel_error_quark (void)
+{
+	static GQuark quark = 0;
+
+	if (quark == 0)
+		quark = g_quark_from_string ("acme-fblevel-quark");
+
+	return quark;
+}
+
 int
 acme_fblevel_get_level (AcmeFblevel *self)
 {
@@ -126,17 +138,48 @@
 }
 
 AcmeFblevel *
-acme_fblevel_new (void)
+acme_fblevel_new (GError **error)
 {
 	AcmeFblevel *self;
 	int fd, foo;
+  gchar *macio, *backlight;
+	/* if there is no /proc/device-tree/aliases/via-pmu, we quit */
+	if (!g_file_test ("/proc/device-tree/aliases/via-pmu", G_FILE_TEST_EXISTS)) {
+		return NULL;
+	}
 
-	if (g_file_test ("/dev/pmu", G_FILE_TEST_EXISTS) == FALSE)
+	/* if there is no /proc/device-tree/aliases/mac-io, we quit too */
+	if (!g_file_test ("/proc/device-tree/aliases/mac-io", G_FILE_TEST_EXISTS)) {
 		return NULL;
+	}
+
+	/* if there is no /proc/device-tree/`cat /proc/device-tree/aliases/mac-io`/backlight
+	 * we quit too */
+  if (!g_file_get_contents("/proc/device-tree/aliases/mac-io", &macio, 
+                           NULL, NULL)) {
+    return NULL;
+  }
+  /* just to be sure */
+  g_strstrip(macio);
+  backlight = g_strdup_printf("/proc/device-tree/%s/backlight", macio);
+  g_free(macio);
 
-	if (acme_fblevel_is_powerbook () == FALSE)
+	if (g_file_test(backlight, G_FILE_TEST_EXISTS) == FALSE ) {
+		g_free(backlight);
 		return NULL;
+	}
+	g_free(backlight);
+	
+	/* if there is no /dev/pmu, we warn the user silently and quit. */
+	if (g_file_test ("/dev/pmu", G_FILE_TEST_EXISTS) == FALSE) {
+		*error = g_error_new_literal (ACME_FBLEVEL_ERROR,
+					      ACME_FBLEVEL_ERROR_NO_PMU_DEVICE,
+					      _("No '/dev/pmu' device found"));
+		return NULL;
+	}
 
+	/* if /dev/pmu is not writable, we warn the user silently, and quit. */
+	
 	self = ACME_FBLEVEL (g_object_new (ACME_TYPE_FBLEVEL, NULL));
 	/* This function switches the kernel backlight control off.
 	 * This is part of the PPC kernel branch since version
@@ -147,31 +190,14 @@
 	 * Notice nicked from pbbuttons*/
 	fd  = open ("/dev/pmu", O_RDWR);
 	/* We can't emit the signal yet, the signal isn't connected! */
-	if (fd < 0)
+	if (fd < 0) {
+		*error = g_error_new_literal (ACME_FBLEVEL_ERROR,
+					      ACME_FBLEVEL_ERROR_WRONG_PERMS,
+					      _("No permission to open '/dev/pmu' device"));
 		return NULL;
+	}
 
 	foo = ioctl(fd, PMU_IOC_GRAB_BACKLIGHT, 0);
 	self->_priv->pmu_fd = fd;
 	return self;
 }
-
-gboolean
-acme_fblevel_is_powerbook (void)
-{
-	FILE *fd;
-	char str[2048];
-	gboolean found = FALSE;
-
-	fd = fopen ("/proc/cpuinfo", "r");
-	while (!feof (fd) && found == FALSE)
-	{
-		fread (str, 1, 2048, fd);
-		if (strstr (str, "PowerBook") != NULL)
-			found = TRUE;
-	}
-
-	fclose (fd);
-
-	return found;
-}
-
diff -aur control-center-2.8.1.vanilla/gnome-settings-daemon/actions/acme-fb-level.h control-center-2.8.1/gnome-settings-daemon/actions/acme-fb-level.h
--- control-center-2.8.1.vanilla/gnome-settings-daemon/actions/acme-fb-level.h	2005-01-25 22:04:12.000000000 +0100
+++ control-center-2.8.1/gnome-settings-daemon/actions/acme-fb-level.h	2005-01-25 22:05:04.000000000 +0100
@@ -29,9 +29,12 @@
 #define ACME_IS_FBLEVEL(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), ACME_TYPE_FBLEVEL))
 #define ACME_FBLEVEL_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), ACME_TYPE_FBLEVEL, AcmeFblevelClass))
 
+#define ACME_FBLEVEL_ERROR		(acme_fblevel_error_quark ())
+
 typedef struct AcmeFblevelPrivate AcmeFblevelPrivate;
 typedef struct AcmeFblevel AcmeFblevel;
 typedef struct AcmeFblevelClass AcmeFblevelClass;
+typedef enum   AcmeFblevelError	AcmeFblevelError;
 
 struct AcmeFblevel {
 	GObject parent;
@@ -44,12 +47,19 @@
 	GObjectClass parent;
 };
 
+enum AcmeFblevelError {
+	ACME_FBLEVEL_ERROR_NO_PMU_DEVICE,
+	ACME_FBLEVEL_ERROR_NO_POWERBOOK,
+	ACME_FBLEVEL_ERROR_WRONG_PERMS
+};
+
 GType acme_fblevel_get_type			(void);
+GQuark acme_fblevel_error_quark			(void);
 int acme_fblevel_get_level			(AcmeFblevel *self);
 void acme_fblevel_set_level			(AcmeFblevel *self, int val);
 gboolean acme_fblevel_get_dim			(AcmeFblevel *self);
 void acme_fblevel_set_dim			(AcmeFblevel *self,
 						 gboolean val);
-AcmeFblevel *acme_fblevel_new			(void);
+AcmeFblevel *acme_fblevel_new			(GError **error);
 gboolean acme_fblevel_is_powerbook		(void);
 
diff -aur control-center-2.8.1.vanilla/gnome-settings-daemon/gnome-settings-multimedia-keys.c control-center-2.8.1/gnome-settings-daemon/gnome-settings-multimedia-keys.c
--- control-center-2.8.1.vanilla/gnome-settings-daemon/gnome-settings-multimedia-keys.c	2005-01-25 22:04:12.000000000 +0100
+++ control-center-2.8.1/gnome-settings-daemon/gnome-settings-multimedia-keys.c	2005-01-25 22:05:04.000000000 +0100
@@ -133,26 +133,6 @@
 	}
 }
 
-#ifdef USE_FBLEVEL
-static char*
-permission_problem_string (const char *file)
-{
-	return g_strdup_printf (_("Permissions on the file %s are broken\n"), file);
-}
-
-static void
-fblevel_problem_cb (void)
-{
-	char *msg;
-
-	msg = permission_problem_string ("/dev/pmu");
-	acme_error (msg);
-	g_free (msg);
-
-	return;
-}
-#endif
-
 static char *images[] = {
 	PIXMAPSDIR "/gnome-speakernotes-muted.png",
 	PIXMAPSDIR "/gnome-speakernotes.png",
@@ -913,6 +893,7 @@
 {
 	GSList *l;
 	Acme   *acme;
+	GError *err = NULL;
 
 	acme = g_new0 (Acme, 1);
 	acme->xml = NULL;
@@ -932,11 +913,10 @@
 
 #ifdef USE_FBLEVEL
 	/* initialise Frame Buffer level handler */
-	if (acme_fblevel_is_powerbook () != FALSE)
-	{
-		acme->levobj = acme_fblevel_new();
-		if (acme->levobj == NULL)
-			fblevel_problem_cb ();
+	acme->levobj = acme_fblevel_new (&err);
+	if (acme->levobj == NULL && err != NULL) {
+		g_critical(err->message);
+		g_error_free (err);
 	}
 #endif
 
